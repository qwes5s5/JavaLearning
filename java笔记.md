## 基础

- 在对运算结果是小数的内容进行判断时，要小心，应该使用两个数差值的绝对值在某个精度范围内判断

- byte，short，char 他们三者可以计算，在计算时首先转换为 int 类型

- byte b2 = 1;byte b3 = 2;short s1 = 1;
  //short s2 = b2 + s1;//错, b2 + s1 => int //byte b4 = b2 + b3; //错误: b2 + b3 => int

- //对于&&短路与而言，如果第一个条件为 false ,后面的条件不再判断

  //对于&逻辑与而言，如果第一个条件为 false ,后面的条件仍然会判断

- ^异或，两个条件不相同时为真

- 条件表达式 ? 表达式 1: 表达式 2;

  运算规则：如果条件表达式为 true，运算后的结果是表达式 1；如果条件表达式为 false，运算后的结果是表达式 2

- 逻辑右移>>>在左端补k个0，算术右移是在左端补k个最高有效位的值

- 当a%b a为小数时， a%b = a - (int)a/b*b

- 数组内元素要满足自动类型转换，例如int a[] = {0.1}不可行

## 面向对象

- P221对象在内存中的存在形式，P225类和对象的内存分配机制，对象赋值会赋予地址

- Java 内存的结构分析 1) 栈： 一般存放基本数据类型(局部变量) 2) 堆： 存放对象(Cat cat , 数组等) 3) 方法区：常量池(常量，比如字符串)， 类加载信

- 当程序执行到方法时，就会开辟一个独立的空间(栈空间)

- 方法不能嵌套定义

- 跨类中调用方法：需要通过对象名调用, 创建对象, 然后在调用方法即可

- 重载返回类型没有要求，可以不同，但仅有返回类型的不同不可以构成重载。形参类型不同也可以构成重载，也就是说，类型、个数、顺序至少有一个不同

- 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
  public void f2(String str, double... nums) { }

- 对象创建流程
  1.在方法区中加载Person类信息(Person.class)，只会加载一次

  2.在堆中分配空间(地址)

  3.完成对象初始化[3.1默认初始化 age=0 name=null 3.2显式初始化age=90,name=null,3.3构造器的初始化 age =20,name=小倩，小倩数据存放在常量池中]

  4.在对象在堆中的地址,返回给p(p是对象名,也可以理解成是对象的引用)

- 封装三步：属性私有化、公共set、公共get

- 哪个对象调用，this就代表哪个对象

- this()构造器方法只能在构造器中使用(即只能在构造器中访问另外一个构造器, **必须放在第一 条语句**)

- 只有public和默认可以修饰类

- 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，**如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。**

- super(参数列表) 只能放在构造器的第一句，而且只能出现一句。

- super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；

-  如果多个基类(上级类)中都有同名的成员，使用 super 访问遵循就近原则。A->B->C

- 如果查找方法的过程中，找到了，但是不能访问， 则报错, cannot access ，如果查找方法的过程中，没有找到，则提示方法不存在

- 方法和属性的查找规则(1) 先找本类，如果有，则调用 //(2) 如果没有，则找父类(如果有，并可以调用，则调用) //(3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 

- this()和super()不可以同时出现在同一个构造函数中

- 实现方法重写/覆盖时(override)，形参列表，方法名称子类与父类要一致

- 实现方法重写/覆盖时，子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类

- 父类 返回类型是 Object , 子类方法返回类型可以是 String，交换则不对

- 在访问修饰符方面，子类方法不能缩小父类方法的访问权限

- 重载发生在本类，覆盖重写发生在父子类

- 属性不可以重写

- (1)一个对象的编译类型和运行类型可以不一致 Animal animal = new Dog();编译类型Animal，运行类型Dog
  (2)编译类型在定义对象时，就确定了,不能改变
  (3)运行类型是可以变化的.
  (4)编译类型看定义时=号的左边，运行类型看=号的右边

-  多态的前提是：两个对象(类)存在继承关系

- 多态向上转型时无法调用子类中的特有成员，因为在编译阶段，能调用哪些成员,是由编译类型来决定的，最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法 ，然后调用，规则我前面我们讲的方法调用规则一致。

- 多态向下转型时，只能强转父类的引用，不能强转父类的对象。同时要求父类的引用必须指向的是当前目标类型的对象

- 向下转型后才可以调用子类类型中所有的成员

- 属性没有重写之说！属性的值看编译类型

- instanceOf 比较操作符，用于判断对象的**运行类型**是否为 XX 类型或 XX 类型的子类型

- 方法调用看运行类型，属性看编译类型

- 动态绑定

  1.当调用**对象方法**的时候，该方法会和该对象的内存地址/**运行类型绑定**
  2.当调用**对象属性**时,**没有动态绑定机制**,哪里声明，那里使用，没有则发挥继承机制

- ==与equals的区别
  ==是一个比较运算符:

  ​	==:既可以判断基本类型，又可以判断引用类型
  ​	==:如果判断基本类型，判断的是值是否相等。示例:int i=10; double d=10.0;3.

  ​	==:如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象【案例说明)】
  equals:

  ​	是Object类中的方法，只能判断引用类型，

  ​	默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如
  Integer,String

  Stirng str1 = new("str");Stirng str2 = new("str");

  str1==str2//为假 str1.equals(str2)//为真

- 1)提高具有哈希结构的容器的效率！ 2) 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ 3) 两个引用，如果指向的是不同对象，则哈希值是不一样的(极小概率一样)

- 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用 monster.toString()

- finalize:当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作。什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 不是一变成垃圾就回收。也可以通过 System.gc()主动触发垃圾回收机制。

  







