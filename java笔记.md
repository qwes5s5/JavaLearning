## 基础

- 在对运算结果是小数的内容进行判断时，要小心，应该使用两个数差值的绝对值在某个精度范围内判断

- byte，short，char 他们三者可以计算，在计算时首先转换为 int 类型

- byte b2 = 1;byte b3 = 2;short s1 = 1;
  //short s2 = b2 + s1;//错, b2 + s1 => int //byte b4 = b2 + b3; //错误: b2 + b3 => int

- //对于&&短路与而言，如果第一个条件为 false ,后面的条件不再判断

  //对于&逻辑与而言，如果第一个条件为 false ,后面的条件仍然会判断

- ^异或，两个条件不相同时为真

- 条件表达式 ? 表达式 1: 表达式 2;

  运算规则：如果条件表达式为 true，运算后的结果是表达式 1；如果条件表达式为 false，运算后的结果是表达式 2

- 逻辑右移>>>在左端补k个0，算术右移是在左端补k个最高有效位的值

- 当a%b a为小数时， a%b = a - (int)a/b*b

- 数组内元素要满足自动类型转换，例如int a[] = {0.1}不可行

## 面向对象

- P221对象在内存中的存在形式，P225类和对象的内存分配机制，对象赋值会赋予地址

- Java 内存的结构分析 1) 栈： 一般存放基本数据类型(局部变量) 2) 堆： 存放对象(Cat cat , 数组等) 3) 方法区：常量池(常量，比如字符串)， 类加载信

- 当程序执行到方法时，就会开辟一个独立的空间(栈空间)

- 方法不能嵌套定义

- 跨类中调用方法：需要通过对象名调用, 创建对象, 然后在调用方法即可

- 重载返回类型没有要求，可以不同，但仅有返回类型的不同不可以构成重载。形参类型不同也可以构成重载，也就是说，类型、个数、顺序至少有一个不同

- 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
  public void f2(String str, double... nums) { }

- 对象创建流程
  1.在方法区中加载Person类信息(Person.class)，只会加载一次

  2.在堆中分配空间(地址)

  3.完成对象初始化[3.1默认初始化 age=0 name=null 3.2显式初始化age=90,name=null,3.3构造器的初始化 age =20,name=小倩，小倩数据存放在常量池中]

  4.在对象在堆中的地址,返回给p(p是对象名,也可以理解成是对象的引用)

- 封装三步：属性私有化、公共set、公共get

- 哪个对象调用，this就代表哪个对象

- this()构造器方法只能在构造器中使用(即只能在构造器中访问另外一个构造器, **必须放在第一 条语句**)

- 只有public和默认可以修饰类

- 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，**如果父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过。**

- super(参数列表) 只能放在构造器的第一句，而且只能出现一句。

- super 的访问不限于直接父类，如果爷爷类和本类中有同名的成员，也可以使用 super 去访问爷爷类的成员；

-  如果多个基类(上级类)中都有同名的成员，使用 super 访问遵循就近原则。A->B->C

- 如果查找方法的过程中，找到了，但是不能访问， 则报错, cannot access ，如果查找方法的过程中，没有找到，则提示方法不存在

- 方法和属性的查找规则(1) 先找本类，如果有，则调用 //(2) 如果没有，则找父类(如果有，并可以调用，则调用) //(3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 

- this()和super()不可以同时出现在同一个构造函数中

- 实现方法重写/覆盖时(override)，形参列表，方法名称子类与父类要一致

- 实现方法重写/覆盖时，子类方法的返回类型和父类方法返回类型一样，或者是父类返回类型的子类

- 父类 返回类型是 Object , 子类方法返回类型可以是 String，交换则不对

- 在访问修饰符方面，子类方法不能缩小父类方法的访问权限

- 重载发生在本类，覆盖重写发生在父子类

- 属性不可以重写

- (1)一个对象的编译类型和运行类型可以不一致 Animal animal = new Dog();编译类型Animal，运行类型Dog
  (2)编译类型在定义对象时，就确定了,不能改变
  (3)运行类型是可以变化的.
  (4)编译类型看定义时=号的左边，运行类型看=号的右边

-  多态的前提是：两个对象(类)存在继承关系

- 多态向上转型时无法调用子类中的特有成员，因为在编译阶段，能调用哪些成员,是由编译类型来决定的，最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法 ，然后调用，规则我前面我们讲的方法调用规则一致。

- 多态向下转型时，只能强转父类的引用，不能强转父类的对象。同时要求父类的引用必须指向的是当前目标类型的对象

- 向下转型后才可以调用子类类型中所有的成员

- 属性没有重写之说！属性的值看编译类型

- instanceOf 比较操作符，用于判断对象的**运行类型**是否为 XX 类型或 XX 类型的子类型

- 方法调用看运行类型，属性看编译类型

- 动态绑定

  1.当调用**对象方法**的时候，该方法会和该对象的内存地址/**运行类型绑定**
  2.当调用**对象属性**时,**没有动态绑定机制**,哪里声明，那里使用，没有则发挥继承机制

- ==与equals的区别
  ==是一个比较运算符:

  ​	==:既可以判断基本类型，又可以判断引用类型
  ​	==:如果判断基本类型，判断的是值是否相等。示例:int i=10; double d=10.0;3.

  ​	==:如果判断引用类型，判断的是地址是否相等，即判定是不是同一个对象【案例说明)】
  equals:

  ​	是Object类中的方法，只能判断引用类型，

  ​	默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等。比如
  Integer,String

  Stirng str1 = new("str");Stirng str2 = new("str");

  str1==str2//为假 str1.equals(str2)//为真

- 1)提高具有哈希结构的容器的效率！ 2) 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的！ 3) 两个引用，如果指向的是不同对象，则哈希值是不一样的(极小概率一样)

- 当直接输出一个对象时，toString 方法会被默认的调用, 比如 System.out.println(monster)； 就会默认调用 monster.toString()

- finalize:当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作。什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 不是一变成垃圾就回收。也可以通过 System.gc()主动触发垃圾回收机制。

### static

- jdk8以前静态变量存放在方法区的静态域中，之后存放在堆中的class对象中

- 类变量的周期是随着类加载开始，随着类消亡而销毁

- 静态变量在普通方法和静态方法中都可以用，静态方法要求用静态变量和静态方法

- 类方法中无this、super的使用

- 静态方法只能被继承，不能被重写

### main方法

- main的args数组中的参数就是执行程序时的参数 java [运行类名] [参数1] [参数2] [参数3]

### 代码块

- 如果多个构造器中都有重复的语句,可以抽取到初始化块(代码块)中，提高代码的重用性

- 相当于另外一种形式的构造器

- static代码块也叫静态代码块，作用就是对类进行初始化,而且它随着类的加载而执行，并且只会执行一次。如果是普通代码块，每创建一个对象就执行一次。

- 类什么时候被加载[重要背!]
  1.创建对象实例时(new)
  2.创建子类对象实例,父类也会被加载
  3.使用类的静态成员时(静态属性,静态方法) A类 extends B类的静态块

- 如果只是使用类的静态成员，普通代码块不会被执行

- **创建一个对象时,在一个类调用顺序是**∶
  ①调用静态代码块和静态属性初始化(注意:静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按他们定义的顺序调用)[举例说明]
  ②调用普通代码块和普通属性的初始化(注意:普通代码块和普通属性初始化调用的优先级一样,如果有多个普通代码块和多个普通属性初始化,则按定义顺序调用)
  ③调用构造方法。

- 构造器的最前面其实隐含了super()和调用普通代码块，

- 静态代码块，静态属性初始化，普通代码块,普通属性初始化，构造方法的调用顺序如下:
  1.父类的静态代码块和静态属性(优先级一样,按定义顺序执行)
  2.子类的静态代码块和静态属性(优先级一样，按定义顺序执行)
  3.父类的普通代码块和普通属性初始化(优先级一样,按定义顺序执行)
  4.父类的构造方法
  5.子类的普通代码块和普通属性初始化(优先级一样，按定义顺序执行)
  6.子类的构造方法

- 静态代码块只能调用静态成员

### 单例设计模式

- 单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法

- 饿汉式

  1)构造器私有化=》防止直接new

  2)类的内部创建对象

  3)向外暴露一个静态的公共方法，getlnstance

- 饿汉式可能会导致创建了对象但是没有使用

- 懒汉式：
  1.仍然構造器私有化
  2.定義一個 static 靜態屬性對象
  3.提供一個 public 的 static 方法，可以返回一個 Cat 對象
  4.懶漢式，只有當用戶使用 getInstance 時，才返回 cat 對象, 後面再次調用時，會返回上次創建的 cat 對象從而保證了單例

- 1．二者最主要的区别在于创建对象的时机不同:饿汉式是在类加载就创建了对象实例,
  而懒汉式是在使用时才创建。

  2．饿汉式不存在线程安全问题，懒汉式存在线程安全问题。

  3．饿汉式存在浪费资源的可能。因为如果程序员一个对象实例都没有使用，那么饿汉
  式创建的对象就浪费了，懒汉式是使用时才创建，就不存在这个问题。

### final关键字

- final的使用时机：1)当不希望类被继承时,可以用final修饰.2)当不希望父类的某个方法被子类覆盖/重写(override)时,可以用final关键字修饰。3)当不希望类的的某个属性的值被修改,可以用final修饰.4)当不希望某个局部变量被修改，可以使用final修饰

- final修饰的属性在定义时,必须赋初值,并且以后不能再修改，赋值可以在如
  下位置之一【选择一个位置赋初值即可】:
  1.定义时;2.在构造器中3.在代码块中

- 如果final修饰的属性是静态的，则初始化的位置只能是
  1.定义时2.在静态代码块不能在构造器中赋值。

- final类不能被继承，但非final类的final方法可以被继承，但不能重写

- final不能修饰构造方法

### 抽象类

- 当一个类中存在抽象方法时，需要将该类声明为 abstract 类

- 抽象类不能被实例化

- 抽象类不一定要包含abstract方法，也就是说抽象类可以没有abstract方法，非抽象方法可以不用重写

- abstract不能修饰属性

- 抽象方法不能有主体{}

- 如果一个类继承了抽象类，那他必须实现抽象类的所有抽象方法，除非他自己也是抽象类。

- 抽象方法不能用private final static来修饰

### 模板设计模式

### 接口

- 接口就是给出一些没有实现的方法,封装到一起,到某个类要使用的时候,在根据具体情况把这些方法写出来

- 接口是更加抽象的抽象的类，抽象类里的方法可以有方法体，接口里的所有方法都没有方法体【jdk7.0】。接口体现了程序设计的多态和高内聚低偶合的设计思想。
  **特别说明**:Jdk8.0后接口类可以有静态方法static修饰，默认方法default修饰，也就是说接口中可以有方法的具体实现

- 在接口中，抽象方法可以省略abstract关键字

- 接口不能被实例化

- 一个普通类实现接口，必须实现接口的所有方法alt+enter，而一个抽象类实现接口，可以不用实现接口的方法

- 接口中，不写public修饰符也是public，而不是默认

- 一个类同时可以实现多个接口

- 接口中的属性,只能是final的,而且是 public static final修饰符。比如:int a=1;实际上是 public static final int a=1;(必须初始化)

- 接口中属性的访问形式:接口名.属性名

- 接口不能继承其它的类,但是可以继承多个别的接口

- 当子类继承了父类，就自动的拥有父类的功能 ，如果子类需要扩展功能，可以通过实现接口的方式扩展. 以理解 实现接口 是 对 java 单继承机制的一种补充

- 接口比继承更加灵活,继承是满足is - a的关系，而接口只需满足 like - a的关系。

- 接口在一定程度上实现代码解耦，这依赖于接口的规范性和动态绑定机制

- 接口类型的变量可以指向实现了接口类的对象实例

- ### 内部类

- 内部类最大的特点就是可以直接访问私有属性，并且可以体现类与类之间的包含关系

- 如果定义类在局部位置(方法中/代码块):(1)局部内部类(2)**匿名内部类**
  定义在成员位置(1)成员内部类(无static)(2)静态内部类(有static)

- 局部内部类不能添加访问修饰符，因为地位就是一个局部变量，但可以用final修饰

- 局部内部类可以直接访问外部类成员，外部类访问局部内部类成员时创建对象直接访问。

- 如果外部类和局部内部类的成员重名时,默认遵循就近原则,如果想访问外部类的成员，则可以使用(外部类名.this.成员)去访问

- 外部类名.this 本质就是外部类的对象, 即哪个对象调用了含有该内部类的方法,Outer02.this 就是哪个对象

- #### 匿名内部类

- new 接口或类(参数列表){类体}

- 匿名内部类的语法比较奇特，请大家注意，因为匿名内部类既是一个类的定义,同时它本身也是一个对象，因此从语法上看，它既有定义类的特征，也有创建对象的特征。

- 匿名内部类多用于直接传参

- #### 成员内部类

- 定义在外部类的成员位置，并且没有static修饰

- 成员内部类可以添加任意访问修饰符

- 第一种方法
  Outer08.Inner08 inner08 = outer08.new Inner08(); inner08.say(); 
  第二方式 在外部类中，编写一个方法，可以返回 Inner08 对象 Outer08.Inner08 inner08Instance = outer08.getInner08Instance();

- #### 静态内部类

- 可以直接访问外部类的所有静态成员，包含私有的，但不能直接访问非静态成员

## 枚举与注解

### 枚举

- 枚举属于一种特殊的类，里面只包含一组有限的特定的对象。
- 自定义实现枚举：
  - 不提供setXxxx方法，构造器私有化，在类内部直接创建固定对象
  - 对枚举对象/属性使用 final + static共同修饰
  - 枚举对象铭全部大写
  - 枚举对象根据修饰可以有多个属性
- 如果使用enum来实现枚举，如果我们使用的是无参构造器，创建常量对象，则可以省略()
- 枚举对象必须放在枚举类的行首
- valueOf 根据字符串查找枚举对象返回
- compareTo 比较两个枚举常量编号，返回前编号减后编号
- enum类不能继承其他类了，因为隐式继承了Enum类，但仍然可以实现接口

### 注解

- 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息
- 三个基本的 Annotation: 
  - @Override: 限定某个方法，是重写父类方法, 该注解只能用于方法
  - @Deprecated: 用于表示某个程序元素(类、方法、字段、包等)已过时
  - @SuppressWarnings: 抑制编译器警告
- @interface 表示一个 注解类，而不是接口
- @Target是修饰注解的注解，成为元注解
- @Deprecated 可以做版本升级过渡使用，不推荐使用，但可以使用
- @SuppressWarnings({""}) 在{""} 中，可以写入你希望抑制(不显示)警告信息
- SuppressWarnings 作用范围是和你放置的位置相关,比如 @SuppressWarnings 放置在 main 方法，那么抑制警告的范围就是 main ,通常我们可以放置具体的语句, 方法,类。
- 四种元注解
  - Retention 指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME 
  - Target 指定注解可以在哪些地方使用 
  - Documented 指定该注解是否会在 javadoc 体现 
  - Inherited 父类使用，子类会继承父类注解

## 常用类

### 包装类

#### Integer

- Object obj1 = true?new Integer(1):nwe Double(2.0) 输出为1.0，因为最高精度为double，三元运算符是一个整体，会自动转换。
- Integer和String的转换
  - Integer转String Integer i = 100
    - 方式 1 String str1 = i + ""; 方式 2 String str2 = i.toString(); 方式 3 String str3 = String.valueOf(i)
  - String转Integer
    - String str4 = "12345"; Integer i2 = Integer.parseInt(str4);//使用到自动装箱 Integer i3 = new Integer(str4);//构造器
- Integer x = i;如果 i 在 IntegerCache.low(-128)~IntegerCache.high(127),就直接从数组返回 ，如果不在 -128~127,就直接 new Integer(i)
- 只有有基本数据类型，判断的是值是否相同,Integer i11=127; int i12=127 i1==i2;

#### String

- 实现Serializable接口 意味着可以串行化:可以在网络传输
- 方式一:直接赋值 String s = "hsp"; 先从常量池查看是否有"hsp"数据空间,如果有，直接指向;如果没有则重新创建，然后指向。S最终指向的是常量池的空间地址
- 方式二:调用构造器 String s2 =new String("hsp");先在堆中创建空间，里面维护了value属性，指向常量池的hsp空间。如果常量池没有"hsp",重新创建,如果有，直接通过value指向。最终指向的是堆中的空间地址。
- String a = "hello" +"abc" 只创建了1个对象.
- p581重要规则，String c1 = "ab" + "cd";常量相加，看的是池。String c1 =a+b;变量相加,是在堆中
- p582综合分析
- split函数 在对字符串进行分割时，如果有特殊字符，需要加入转义符\ 如"\\"
- compareTo 比较两个字符串的大小，如果前者大，则返回正数，后者大，则返回负数，如果相等，返回 0
  - (1) 如果长度相同，并且每个字符也相同，就返回 0 
  - (2) 如果长度相同或者不相同，但是在进行比较时，可以区分大小 就返回 if (c1 != c2) { // return c1 - c2; // } 
  - (3) 如果前面的部分都相同，就返回 str1.len -str2.len
- String保存的是字符串常量，里面的值不能更改，每次String类的更新实际上就是更改地址，效率较低.StringBuffer保存的是字符串变量，里面的值可以更改，每次StringBuffer的更新实际上可以更新内容，不用每次更新地址，效率较高.
- String->StringBuffer 构造器，append() StringBuffer->String 构造器，toString()
- String str = null    StringBuffer sb = new StringBuffer(str);不可以 sb.append(str);可以
- StringBuilder一个可变的字符序列。此类提供一个与StringBuffer 兼容的API,但不保证同步(StringBuilder 不是线程安全)。该类被设计用作 StringBuffer的一个简易替换,用在字符串缓冲区被单个线程使用的时候。如果可能，建议优先采用该类因为在大多数实现中，它比 StringBuffer 要快。
- StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用  StringBuilder
- string s="a";//创建了一个字符串
  s += "b";//实际上原来的"a"字符串对象已经丢弃了，现在又产生了一个字符串s+"b”(也就是"ab")。如果多次执行这些改变串内容的操作，会导致大量副本字符串对象存留在内存中，降低效率。如果这样的操作放到循环中，会极大影响程序的性能=>结论:如果我们对String做大量修改,不要使用String
- 使用的原则,结论:
  - 如果字符串存在大量的修改操作，一般使用 StringBuffer 或StringBuilder
  - 如果字符串存在大量的修改操作，并在单线程的情况,使用 StringBuilder
  - 如果字符串存在大量的修改操作，并在多线程的情况,使用StringBuffer
  - 如果我们字符串很少修改，被多个对象引用,使用String, 比如配置信息等

#### Math

